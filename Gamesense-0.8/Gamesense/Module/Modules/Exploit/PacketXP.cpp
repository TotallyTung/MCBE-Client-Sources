#include "PacketXP.h"
int initDelay = 0;
int veryFastDelay = 2;
int fastDelay = 5;
int midDelay = 10;
int slowDelay = 15;
bool feetPlace = false;
bool onClick = true;
bool noMCF = false;
SettingEnum clickMode;
int armorPercent = 100;
using namespace std;
PacketXP::PacketXP() : IModule(0, Category::EXPLOIT, "Use XP Fast and Silently") {
    registerIntSetting("Waste Amount", &speed, speed, 1, 5, "Waste multiplier of EXP");
    registerBoolSetting("Prevent Friend", &noMCF, noMCF, "Stops you from mid click exping when pointing at someone so you dont friend them");
    registerBoolSetting("Feet", &feetPlace, feetPlace);
    registerIntSetting("Armor %", &armorPercent, armorPercent, 1, 100, "Only activate when armor is at a certain percentage, set to 100 to always activate");
    registerEnumSetting("Mode", &clickMode, 0);
    clickMode.addEntry("Auto", 0);
    clickMode.addEntry("MidClick", 1);
    clickMode.addEntry("RightClick", 2);
    registerEnumSetting("Swap", &swap, 0);
    swap.addEntry("None", 0);
    swap.addEntry("Silent", 1);
}

const char* PacketXP::getRawModuleName() {
    return "PacketXP";
}

vector<string> items = {
    "bottle"
};
void getEXP()
{
    C_PlayerInventoryProxy* supplies = g_Data.getLocalPlayer()->getSupplies();
    C_Inventory* inv = supplies->inventory;
    for (int n = 0; n < 9; n++)
    {
        C_ItemStack* stack = inv->getItemStack(n);
        if (stack->item != nullptr)
        {
            if (stack->getItem()->itemId == 508)
            {
                supplies->selectedHotbarSlot = n;
                return;
            }
        }
    }
}
void PacketXP::onTick(C_GameMode* gm) {
    auto player = g_Data.getLocalPlayer();
    C_Entity* entity = g_Data.getLocalPlayer()->pointingStruct->getEntity();
    // if pointing at someone then don't exp
    if (entity != nullptr && noMCF)
        return;

    if (player == nullptr || gm == nullptr)
        return;

    if (clickMode.getSelectedValue() == 2 && !g_Data.isRightClickDown())
        return;

    if (clickMode.getSelectedValue() == 1 && !GameData::isWheelDown())
        return;

    if (g_Data.canUseMoveKeys()) {
        auto supplies = g_Data.getLocalPlayer()->getSupplies();
        auto inv = supplies->inventory;
        expSlot = supplies->selectedHotbarSlot;

        if (swap.getSelectedValue() == 1)
            getEXP();

        // Check armor durability
        bool armorNeedsXP = false;
        for (int i = 0; i < 4; i++) {
            C_ItemStack* stack = player->getArmor(i);
            if (stack->item != nullptr) {
                float dura1 = stack->getItem()->getMaxDamage();
                float dura2 = stack->getItem()->getDamageValue(stack->tag);
                float dura3 = dura1 - dura2;
                int dura4 = dura3 / dura1 * 100;
                int armorPercent2 = armorPercent;
                // If its 100 then just make it always exp
                if (armorPercent >= 100)
                    armorPercent2 = 101;
                if (dura4 < armorPercent2) {
                    armorNeedsXP = true;
                    break;
                }
            }
        }

        if (armorNeedsXP) {
            C_ItemStack* stack = player->getSupplies()->inventory->getItemStack(player->getSupplies()->selectedHotbarSlot);

            if (stack->item != nullptr && (*stack->item)->itemId != 0) {
                string itemName = stack->getItem()->name.getText();

                for (auto item : items) {
                    if (itemName.find(item) != string::npos) {
                        // XP usage based on speed
                        if (feetPlace)
                        g_Data.getLocalPlayer()->setRot(vec2_t(90, 0));
                        for (int i = 0; i < speed; i++) {
                            gm->useItem(*stack);
                        }
                       
                    }
                }
            }
        }

        if (swap.getSelectedValue() == 1)
            supplies->selectedHotbarSlot = expSlot;
    }
}

void PacketXP::onSendPacket(C_Packet* packet) {
}